# 网络安全



### 什么情况会出现跨域？

1. 由于受到浏览器的安全限制策略（同源策略），所以在浏览器中发送AJAX请求会出现跨域问题。
2. 同源策略，在一串IP地址中，只要以下任意一个条件不同就会产生跨域。
   + 协议不同
   + 域名不同
   + IP端口不同
3. 浏览器的同源策略不是说拒绝发送AJAX请求，而是不接收跨域请求的响应数据。



### 如何解决跨域？

1. 通过JSONP（利用script标签不跨域的特点，但是只支持GET）。

2. 配置webpack代理/nginx代理。

3. 后端设置 CORS Header。

   | CORS Header属性                  | 解释                                                         |
   | :------------------------------- | :----------------------------------------------------------- |
   | Access-Control-Allow-Origin      | 允许http://www.xxx.com域（自行设置，这里只做示例）发起跨域请求 |
   | Access-Control-Max-Age           | 设置在86400秒不需要再发送预校验请求                          |
   | Access-Control-Allow-Methods     | 设置允许跨域请求的方法                                       |
   | Access-Control-Allow-Headers     | 允许跨域请求包含content-type                                 |
   | Access-Control-Allow-Credentials | 设置允许Cookie                                               |




### 什么是认证和授权？如何设计⼀个权限认证框架？

1. 认证： 就是对系统访问者的身份进⾏确认。
2. 授权：就是对系统访问者的⾏为进⾏控制。授权通常是在认证之后，对系统内的⽤户隐私数据进⾏护，包括：后台接⼝访问权限、前台控件的访问权限。
3. RBAC模型： 主体 -> ⻆⾊ -> 资源 -> 访问系统的⾏为。
4. 认证和授权也是对⼀个权限认证框架进⾏扩展的两个主要的⽅⾯。



### 如果没有Cookie,Session还能进⾏身份验证吗？

1. 当服务器tomcat第⼀次接收到客户端的请求时，会开辟⼀块独⽴的session空间，建⽴⼀个session对象，同时会⽣成⼀个session id，通过响应头的⽅式保存到客户端浏览器的cookie当中。以后客户端的每次请求，都会在请求头部带上这个session id，这样就可以对应上服务端的⼀些会话的相关信息，⽐如⽤户的登录状态。
2. 如果没有客户端的Cookie，Session是⽆法进⾏身份验证的。



### 什么是CSRF攻击？如何防⽌？

1. CSRF： Cross Site Requst Forgery 跨站请求伪造，⼀个正常的请求会将合法⽤户的session id保存到浏览器的cookie。这时候，如果⽤户在浏览器中打来另⼀个tab⻚， 那这个tab⻚也是可以获得浏览器的cookie。⿊客就可以利⽤这个cookie信息进⾏攻击。
2. CSRF防⽌⽅式：
   + 尽量使⽤POST请求，限制GET请求。POST请求可以带请求体，攻击者就不容易伪造出请求。
   + 将cookie设置为HttpOnly : respose.setHeader("SetCookie","cookiename=cookievalue;HttpOnly")。
   + 增加token。
   + 在请求中放⼊⼀个攻击者⽆法伪造的信息，并且该信息不存在于cookie当中。这也是SpringSecurity框架中采⽤的防范⽅式。



### 什么是OAuth2.0协议？有哪⼏种认证⽅式？

1. OAuth2.0是⼀个开放标准，允许⽤户授权第三⽅应⽤程序访问他们存储在另外的服务提供者上的信息，⽽不需要将⽤户名和密码提供给第三⽅应⽤或分享他们数据的所有内容。

   

2. OAuth2.0协议的认证流程，简单理解，就是允许我们将之前的授权和认证过程交给⼀个独⽴的第三⽅进⾏担保。

   

3. OAuth2.0协议中的几个角色：

   + 客户端：本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源。
   + 资源拥有者：通常为用户，也可以是应用程序，即该资源的拥有者。
   + 授权服务器（也称认证服务器）：用于服务提供商对资源拥有的身份进行认证、对访问资源进行授权，认证成功后会给客户端发放令牌 （access_token），作为客户端访问资源服务器的凭据。l例如：微信的认证服务器、支付宝的认证服务器。
   + 资源服务器：存储资源的服务器。
     + 例如：微信、支付宝等包含用户信息服务器，可以通过认证服务器认证之后，通过access_token获取微信、支付宝保存的用户信息。

   

4. OAuth2.0协议有四种认证⽅式：

   + 授权码模式
   + 简化模式
   + 密码模式
   + 客户端模式



### 什么是SSO？与OAuth2.0有什么关系？

1. OAuth2.0的使⽤场景通常称为联合登录， ⼀处注册，多处使⽤。
2. SSO （Single Sign On） 单点登录。 ⼀处登录，多处同时登录。



### 如何设计⼀个开放授权平台？

1. 开放授权平台也可以按照认证和授权两个⽅向来梳理。

2. 认证： 就可以按照OAuth2.0协议来规划认证的过程。

3. 授权：

   + ⾸先需要待接⼊的第三⽅应⽤在开放授权平台进⾏注册，注册需要提供⼏个必要的信息clintID, 消息推送地址，密钥(⼀对公私钥，私钥由授权平台⾃⼰保存，公钥分发给第三⽅应⽤)。
   + 然后，第三⽅应⽤引导客户发起请求时，采⽤公钥进⾏参数加密，授权开放平台使⽤对应的私钥解密。
   + 接下来：授权开放平台同步响应第三⽅应⽤的只是消息是否处理成功的结果。⽽真正的业务数据由授权开放平台异步推动给第三⽅应⽤预留的推送地址。

   

### TCP的三次握⼿和四次挥⼿？

1. TCP协议是7层⽹络协议中的传输层协议，负责数据的可靠传输。

   

2. 在建⽴TCP连接时，需要通过三次握⼿来建⽴，过程是：

   + 客户端向服务端发送⼀个SYN。
   + 服务端接收到SYN后，给客户端发送⼀个SYN_ACK。
   + 客户端接收到SYN_ACK后，再给服务端发送⼀个ACK。

   

3. 在断开TCP连接时，需要通过四次挥⼿来断开，过程是：

   + 客户端向服务端发送FIN
   + 服务端接收FIN后，向客户端发送ACK，表示我接收到了断开连接的请求，客户端你可以不发数据了，不过服务端这边可能还有数据正在处理。
   + 服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接。
   + 客户端收到服务端的FIN，向服务端发送ACK，表示客户端也会断开连接了。



### 浏览器发出⼀个请求到收到响应经历了哪些步骤？

1. 浏览器解析⽤户输⼊的URL，⽣成⼀个HTTP格式的请求。
2. 先根据URL域名从本地hosts⽂件查找是否有映射IP，如果没有就将域名发送给电脑所配置的DNS进⾏域名解析，得到IP地址。
3.  浏览器通过操作系统将请求通过四层⽹络协议发送出去，途中可能会经过各种路由器、交换机，最终到达服务器。
4. 服务器收到请求后，根据请求所指定的端⼝，将请求传递给绑定了该端⼝的应⽤程序，⽐如8080被tomcat占⽤了。
5. tomcat接收到请求数据后，按照http协议的格式进⾏解析，解析得到所要访问的servlet。
6. 然后servlet来处理这个请求，如果是SpringMVC中的DispatcherServlet，那么则会找到对应的Controller中的⽅法，并执⾏该⽅法得到结果。
7. Tomcat得到响应结果后封装成HTTP响应的格式，并再次通过⽹络发送给浏览器所在的服务器。
8. 浏览器所在的服务器拿到结果后再传递给浏览器，浏览器则负责解析并渲染。





### 零拷⻉是什么？

1. 零拷⻉指的是，应⽤程序在需要把内核中的⼀块区域数据转移到另外⼀块内核区域去时，不需要经过先复制到⽤户空间，再转移到⽬标内核区域去了，⽽直接实现转移。