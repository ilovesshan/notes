# Redis

### 什么是RDB和AOF？

1. RDB（Redis DataBase）：在指定的时间间隔内将内存中的数据集快照写⼊磁盘，实际操作过程是fork⼀个⼦进程，先将数据集写⼊临时⽂件，写⼊成功后，再替换之前的⽂件，⽤⼆进制压缩存储。
2. AOF（Append Only File）：以⽇志的形式记录服务器所处理的每⼀个写、删除操作，查询操作不会记录，以⽂本的⽅式记录，可以打开⽂件看到详细的操作记录。
3. AOF⽂件⽐RDB更新频率⾼，优先使⽤AOF还原数据，AOF⽐RDB更安全也更⼤，RDB性能⽐AOF好，如果两个都配了优先加载AOF。



### Redis的持久化机制？

1. RDB：Redis DataBase 将某⼀个时刻的内存快照（Snapshot），以⼆进制的⽅式写⼊磁盘。
2. ⼿动触发
   + save命令，使 Redis 处于阻塞状态，直到 RDB 持久化完成。
   + bgsave命令，fork出⼀个⼦进程执⾏持久化，主进程只在fork过程中有短暂的阻塞，⼦进程创建之后，主进程就可以响应客户端请求了。
3. ⾃动触发
   + save m n ：在 m 秒内，如果有 n 个键发⽣改变，则⾃动触发持久化。
   + flushall：⽤于清空redis所有的数据库。
   + flushdb：清空当前redis所在库数据。



### Redis的过期键的删除策略？

1. Redis中同时使⽤了惰性过期和定期过期两种过期策略。
2. 惰性过期
   + 只有当访问⼀个key时，才会判断该key是否已过期，过期则清除。
   + 该策略可以最⼤化地节省CPU资源，却对内存⾮常不友好。极端情况可能出现⼤量的过期key没有再次被访问，从⽽不会被清除，占⽤⼤量内存。
3. 定期过期
   + 每隔⼀定的时间，会扫描⼀定数量的数据库的expires字典中⼀定数量的key，并清除其中已过期的key。
   + 该策略是⼀个折中⽅案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。



### Redis有哪些数据结构？分别有哪些典型的应⽤场景？

1. 字符串：可以⽤来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利⽤了这种数据结构，还包括可以实现计数器、Session共享、分布式ID。
2. 哈希表：可以⽤来存储⼀些key-value对，更适合⽤来存储对象。
3. 列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使⽤，可以⽤来缓存类似微信公众号、微博等消息流数据。
4. 集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进⾏交集、并集、差集操作，从⽽可以实现类似，我和某⼈共同关注的⼈、朋友圈点赞等功能。
5. 有序集合：集合是⽆序的，有序集合可以设置顺序，可以⽤来实现排⾏榜功能。



### Redis缓存三兄弟？

1. 缓存雪崩

   + 概念：如果缓存中某⼀时刻⼤批热点数据同时过期，那么就可能导致⼤量请求直接访问Mysql了。
   + 解决办法：
     + 在过期时间上增加⼀点随机值。
     + 如果搭建⼀个⾼可⽤的Redis集群也是防⽌缓存雪崩的有效⼿段。

   

2. 缓存击穿

   + 概念：和缓存雪崩类似，缓存雪崩是⼤批热点数据失效，⽽缓存击穿是指某⼀个热点key突然失效，也导致了⼤量请求直接访问Mysql数据库。
   + 解决办法：考虑这个热点key不设过期时间

   

3. 缓存穿透

   + 概念：假如某⼀时刻访问redis的⼤量key都在redis中不存在（⽐如⿊客故意伪造⼀些乱七⼋糟的key），那么也会给数据造成压⼒。
   + 解决办法：使⽤布隆过滤器，它的作⽤就是如果它认为⼀个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加⼀层布隆过滤器来拦截不存在的key。



### Redis和Mysql如何保证数据⼀致？

1. 先更新Mysql，再更新Redis，如果更新Redis失败，可能仍然不⼀致。
2. 先删除Redis缓存数据，再更新Mysql，再次查询的时候在将数据添加到缓存中。
   + 这种⽅案能解决1⽅案的问题，但是在⾼并发下性能较低，⽽且仍然会出现数据不⼀致的问题。
   + ⽐如线程1删除了Redis缓存数据，正在更新Mysql，此时另外⼀个查询再查询，那么就会把Mysql中⽼数据⼜查到Redis中。
3. 延时双删，步骤是：先删除Redis缓存数据，再更新Mysql，延迟⼏百毫秒再删除Redis缓存数据，这样就算在更新Mysql时，有其他线程读了Mysql，把⽼数据读到了Redis中，那么也会被删除掉，从⽽把数据保持⼀致。
