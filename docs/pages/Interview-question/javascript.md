# JavaScript

### js基本数据类型和引用数据类型？

1. js基本数据类型：string、boolean、int、null、undefined、Symbol。
2. 引用数据类型：Object、Array、Date、RegExp、Function。



### js变量和函数声明的提升？

1. 在js中函数和变量的声明默认会提升到最顶部。
2. 函数的提升优先级高于变量的提升。
3. 如果函数内部用var声明了相同名称的外部变量，函数将不再向上查找。
4. 匿名函数不会提升。



### 对闭包的理解？

1. 闭包简单理解就是：能够读取其他函数内部变量的函数，表现形式为：一个函数内部返回一个函数。
2. 闭包的优缺点：
   + 优点：能够读取函数内部变量、能够将变量保存在内存中。可以通过闭包来封装私有属性和方法。
   + 缺点：比较耗费内存、使用不当会造成内存溢出的问题。



### == 和 ===的区别？

1. == 是非严格意义上的等于，只要是值相等就返回true。
2. ===是严格意义上的相等，会比较两边的数据类型、值大小值和引用地址都相等才相等。



### 对this的理解以及绑定规则

1. this的理解

   + 每个函数在被调用时都会创建一个执行上下文，这个上下文包含了`变量环境`、`this`、`作用域链`等。this就是执行上下文中的一个属性，他是在函数运行时进行绑定的，this的绑定和函数的声明位置没有关系，它取决于函数的调用方式。

   

2. this指向

   + 非严格模式下this默认指向window，严格模式this默认指向undefined。
   + this总是指向函数的直接调用者。
   + 如果有new关键字，this指向new出来的对象。
   + 在事件中，this指向触发这个事件的对象

   

3. this绑定规则

   + 默认绑定：最常见就是函数的独立调用。
   + 隐式绑定：函数作为对象的方法被调用，此时this会指向这个对象。
   + 显示绑定：直接将某个对象直接绑定到this上，此时这个this就指向这个对象，一般我们通过call/apply/bind来实现显示绑定。
   + new绑定：使用new方法时函数会作为构造函数，最终返回一个新的对象，而这个函数中的this会直接指向这个新的对象。
   + 箭头函数：调用箭头函数时，不会隐式的传入this，而是从定义时的函数继承上下文。



### 常见的数组和对象的遍历方式？

1. for循环
2. for each： 适用于需要知道索引值的数组遍历。
3. for in ：可以遍历 对象 字符串， 数组，但是由于for 会迭代原型上的可遍历属性，因此他的性能比较差。
4. for of：可以遍历 数组，部分类数组、字符串、Set和Map，对象默认不具有遍历器机制，如果想要使用for of遍历就必须在对象原型上加遍历器。



### forEach与map的区别？

1. forEach是最基本的方法，就是遍历与循环，默认有三个参数：当前item项、当前索引、遍历数组。forEach里面不能使用break关键字，因为：函数里面只能用return或者throw结束。

   

2. map 方法，基本用法与 forEach 一致，但是不同的，它会返回一个新的数组，所以 callback需要有 return 值，如果没有，会返回 undefined。



### 箭头函数与普通函数的区别?

1. 箭头函数相比普通函数：语法更加简洁、清晰。
2. 箭头函数没有 prototype (原型)，也就意味着箭头函数本身没有this，箭头函数也不会自己创建this。
3. call | apply | bind 无法改变箭头函数中this的指向。
4. 箭头函数不可以当作构造函数，箭头函数中不可以使用 arguments 对象，如果要用，可以用 Rest 参数代替。



### 同源策略是什么？

1. 同源指的是域名、协议、端口号相同。



### 如何解决跨域？

1. 传统的jsonp
2. 通过nginx/webpack/node配置代理
3. 后端在头部信息里面设置安全域名



### 严格模式的限制有哪些？

1. 变量必须声明后再使用。
2. 函数的参数不能有同名属性，否则报错。
3. 禁止 this 指向全局对象。



### es6新增的特性？

1. 新增模板字符串。
2. let/const关键字。
3. 箭头函数。
4. 引入 module 模块的概念。
5. for-of方法（用来遍历数据）。
6. 将 Promise 对象纳入规范，提供了原生的 Promise 对象。



### attribute 和 property 的区别是什么?

1. attribute ：HTML 标签上的特性，也就是 html 代码中经常看到的键值对。
2. property ： DOM 中的属性，是 JavaScript 里的对象。



### let和const 的区别是什么?

1. let和const声明的遍历不会提升，如果块区中存在 let 和 const 命令，就会形成封闭作用域不允许重复声明。
2. 如果在let和const声明之前使用变量会报错。
3. let定义的变量可以被修改，const定义的是常量，不能修改，但是如果定义的是对象，可以修改对象内部的数据。



### 什么是内存泄漏？

1. 内存泄漏是指：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
2. js中可能出现的内存泄漏情况
   + 过多的全局变量。
   + dom 清空时，还存在引用。
   + 定时器未清除。
   + 事件监听未清除。



### 常用的数组(array)方法？

1. map : 遍历数组，返回回调返回值组成的新数组。
2. forEach : 无法 break ，可以用 try/catch 中 throw new Error 来停止。
3. filter : 过滤。
4. some : 有一项返回 true ，则整体为 true。
5. every : 有一项返回 false ，则整体为 false。
6. join : 通过指定连接符生成字符串。
7. push / pop : 末尾推入和弹出，改变原数组， 返回数组新的长度。
8. unshift / shift : 头部推入和弹出，改变原数组，返回操作项。
9. sort(fn) / reverse : 排序与反转，改变原数组。
10. concat : 连接数组，不影响原数组， 浅拷贝。
11. slice(start, end) : 返回截断后的新数组，不改变原数组。
12. splice(start,number,value…): 返回删除元素组成的数组，value 为插入项，改变原数组。
13. indexOf / lastIndexOf(value, fromIndex) : 查找数组项，返回对应的下标。
14. reduce / reduceRight(fn(prev, cur) ，defaultPrev) : 两两执行，prev 为上次化简函数的return 值，cur 为当前值(从第二项开始)。



### 说说异步编程的实现方式?

1. 回调函数
2. 事件监听
3. 发布和订阅模式
4. Promise/async 函数



### 深浅拷贝的区别？

1. 数据存储方式：

   + 基础数据类型：值都有固定的大小，保存在栈内存中，由系统自动分配存储空间在栈内存空间的值，我们可以直接进行操作，因此基础数据类型都是按照值访问。
   + 复杂数据类型，值都保存在堆内存中的对象，引用类型的值都是按引用访问的，所以在操作对象时，实际上是操作对象的引用而不是实际的对象。引用可以理解为保存在栈内存中的一个地址，该地址指向堆内存中的一个实际对象。

   

2. 数据复制的方式：

   + 基础数据类型：在栈空间新建一个空间去进行复制。
   + 引用类型复制：系统会为新的变量自动分配一个新的栈内存空间这个栈内存空间保存着与被复制变量相同的指针，尽管他们在内存中的内存空间的位置互相独立但是在堆内存中访问到的对象实际上是同一个。

   

3. 深浅拷贝的区别总结：

   + 深拷贝除了会复制新建栈空间的值，同时还在将指向堆内存中对象进行新建（完全是一份新的）。
   + 浅拷贝只会对引用类型的值做第一层堆内存进行拷贝。

   

4. 深浅拷贝实现工具类思路：

   + 深拷贝： 需要对整个对象的进行深度遍历赋复制和新建，从而实现修改新建值不会影响到原有的值。
   + 浅拷贝：只需要对引用对象的第一层值进行拷贝。



### 什么是单线程，和异步的关系？

1.  js 单线程的代码是一行一行执行的，而 js 执行的时候，浏览器 DOM 渲染会暂停，如果是同步执行的话，遇到耗时操作时会造成页面卡顿，长时间无响应等。
2.  js 的耗时操作(如：定时器、Ajax请求等)都是异步执行，其它操作是同步执行的。
   + 每当遇到耗时操作就会记录下来（会等待耗时结束后，将异步函数放入异步队列），不等待这个操作执行完，直接执行一个操作。
   + 等待同步操作执行完，就会发起事件轮询，检查异步队列是否为空，如果不为空，就会执行里面的操作。
3. 异步是 js 单线程的解决方案。





### 什么是作用域链？

1. 作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。



### 什么是原型、原型链？

1. 原型：所有的函数都有prototype属性，使用原型对象的好处是所有对象实例共享它所包含的属性和方法。
2. 原型链：每个对象拥有一个原型对象，通过 \_proto\_ 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null (Object.proptotype\.__proto\__指向的是null)。这种关系被称为原型链，通过原型链一个对象可以拥有定义在其他对象中的属性和方法。



### prototype 和 proto 区别是什么

1. prototype是构造函数的属性。
2. `__proto__`是每个实例都有的属性，可以访问 [[prototype]] 属性，实例的`__proto__`与其构造函数的prototype指向的是同一个对象。



### js垃圾回收机制是怎样的？

1. js的垃圾回收机制是为了防止内存泄漏（已经不需要的某一块内存还一直存在着），垃圾回收机制就是不停歇的寻找这些不再使用的变量，并且释放掉它所指向的内存。

   

2. 变量的生命周期，当一个变量的生命周期结束之后，它所指向的内存就会被释放。js有两种变量，局部变量和全局变量。

   + 局部变量是在他当前的函数中产生作用，当该函数结束之后，该变量内存会被释放。
   + 全局变量会一直存在，直到浏览器关闭为止。

   

3. js垃圾回收方式，有两种方式： 标记清除和引用计数。

   + 引用计数： 
     + 当变量进行声明并赋值后，值的引用数为1，当同一个值被赋值给另一个变量时，引用数+1，当保存该值引用的变量被其它值覆盖时，引用数-1，当该值的引用数为0时，表示无法再访问该值了，此时就可以放心地将其清除并回收内存。
     + 当其进行循环引用时就会出现问题，会造成大量的内存不会被释放。这也是后来放弃引用计数，使用标记清除的原因之一。
   + 标记清除：当变量进入执行环境(声明变量）的时候，垃圾回收器将该变量进行了标记，当该变量离开环境的时候，将其再度标记，随之进行删除。





### 项目性能优化常见方式？

1. 减少 HTTP 请求数、减少 DNS 查询。
2. 使用 CDN、避免重定向。
3. 减少 DOM 元素数量、减少 DOM 操作。
4. 使用外部 JavaScript 和 CSS、压缩 JavaScript、CSS、字体、图片等。
5. 优化 CSS Sprite，使用 iconfont、避免图片 src 为空、做图片懒加载。
6. 多域名分发划分内容到不同域名、尽量减少 iframe 使用。
7. 把样式表放在 link 中、把 JavaScript 放在页面底部。



### 简单说说负载均衡？

1. 多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用。
2. 反向代理负载均衡（Nginx）：
   + 访问统一的服务器，由服务器进行调度访问实际的某个服务器。
   + 对统一的服务器要求大，性能受到服务器群的数量。



### 逐进增强和优雅降级?

1. 逐进增强（迭代更新）：
   + 针对低版本浏览器进行构建页面，保证最基本的功能。
   + 然后再针对高版本浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
2. 优雅降级（向下兼容）：
   + 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
